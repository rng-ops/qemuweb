/**
 * Atlas Tool System
 * 
 * Allows panels and components to register tools/capabilities that the Atlas agent
 * can use to interact with the application. Tools can:
 * - Fill UI elements
 * - Modify DOM
 * - Create/update resources
 * - Trigger actions
 * - Query state
 */

import type { AtlasEvent } from './atlasOrchestrator';

// ============ Tool Types ============

export type ToolParameterType = 
  | 'string' 
  | 'number' 
  | 'boolean' 
  | 'array' 
  | 'object' 
  | 'select';

export interface ToolParameter {
  name: string;
  type: ToolParameterType;
  description: string;
  required?: boolean;
  default?: unknown;
  options?: Array<{ label: string; value: string | number }>;
  schema?: Record<string, ToolParameter>; // For object types
}

export interface ToolDefinition {
  id: string;
  category: 'ui' | 'file' | 'container' | 'network' | 'data' | 'system';
  name: string;
  description: string;
  parameters: ToolParameter[];
  examples?: string[];
  panelId: string; // Which panel provides this tool
}

export interface ToolResult {
  success: boolean;
  data?: unknown;
  error?: string;
  events?: AtlasEvent[]; // Events generated by tool execution
}

export type ToolHandler = (params: Record<string, unknown>) => Promise<ToolResult>;

// ============ Tool Registry ============

class AtlasToolRegistry {
  private tools = new Map<string, ToolDefinition>();
  private handlers = new Map<string, ToolHandler>();
  private subscribers = new Set<(tools: ToolDefinition[]) => void>();

  /**
   * Register a tool provided by a panel
   */
  registerTool(tool: ToolDefinition, handler: ToolHandler): void {
    this.tools.set(tool.id, tool);
    this.handlers.set(tool.id, handler);
    this.notifySubscribers();
  }

  /**
   * Unregister a tool (e.g., when panel unmounts)
   */
  unregisterTool(toolId: string): void {
    this.tools.delete(toolId);
    this.handlers.delete(toolId);
    this.notifySubscribers();
  }

  /**
   * Unregister all tools from a panel
   */
  unregisterPanelTools(panelId: string): void {
    for (const [toolId, tool] of this.tools.entries()) {
      if (tool.panelId === panelId) {
        this.tools.delete(toolId);
        this.handlers.delete(toolId);
      }
    }
    this.notifySubscribers();
  }

  /**
   * Execute a tool
   */
  async executeTool(toolId: string, params: Record<string, unknown>): Promise<ToolResult> {
    const handler = this.handlers.get(toolId);
    if (!handler) {
      return {
        success: false,
        error: `Tool '${toolId}' not found`,
      };
    }

    const tool = this.tools.get(toolId);
    if (!tool) {
      return {
        success: false,
        error: `Tool definition for '${toolId}' not found`,
      };
    }

    // Validate required parameters
    const missingParams = tool.parameters
      .filter(p => p.required && !(p.name in params))
      .map(p => p.name);

    if (missingParams.length > 0) {
      return {
        success: false,
        error: `Missing required parameters: ${missingParams.join(', ')}`,
      };
    }

    try {
      return await handler(params);
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Get all registered tools
   */
  getTools(): ToolDefinition[] {
    return Array.from(this.tools.values());
  }

  /**
   * Get tools by category
   */
  getToolsByCategory(category: ToolDefinition['category']): ToolDefinition[] {
    return this.getTools().filter(t => t.category === category);
  }

  /**
   * Get a specific tool definition
   */
  getTool(toolId: string): ToolDefinition | undefined {
    return this.tools.get(toolId);
  }

  /**
   * Subscribe to tool registry changes
   */
  onToolsChanged(callback: (tools: ToolDefinition[]) => void): () => void {
    this.subscribers.add(callback);
    // Immediately notify with current tools
    callback(this.getTools());
    // Return unsubscribe function
    return () => {
      this.subscribers.delete(callback);
    };
  }

  private notifySubscribers(): void {
    const tools = this.getTools();
    for (const subscriber of this.subscribers) {
      subscriber(tools);
    }
  }

  /**
   * Generate tool context string for chat
   */
  getToolContext(): string {
    const tools = this.getTools();
    if (tools.length === 0) {
      return 'No tools currently available.';
    }

    const byCategory = new Map<string, ToolDefinition[]>();
    for (const tool of tools) {
      const category = byCategory.get(tool.category) || [];
      category.push(tool);
      byCategory.set(tool.category, category);
    }

    const lines: string[] = ['Available Tools:'];
    for (const [category, categoryTools] of byCategory) {
      lines.push(`\n${category.toUpperCase()}:`);
      for (const tool of categoryTools) {
        lines.push(`  - ${tool.name}: ${tool.description}`);
        if (tool.examples && tool.examples.length > 0) {
          lines.push(`    Example: ${tool.examples[0]}`);
        }
      }
    }

    return lines.join('\n');
  }
}

// ============ Singleton ============

let registry: AtlasToolRegistry | null = null;

export function getToolRegistry(): AtlasToolRegistry {
  if (!registry) {
    registry = new AtlasToolRegistry();
  }
  return registry;
}

// ============ Built-in Tool Helpers ============

/**
 * Create a simple tool definition
 */
export function createTool(
  id: string,
  name: string,
  description: string,
  category: ToolDefinition['category'],
  panelId: string,
  parameters: ToolParameter[] = []
): ToolDefinition {
  return {
    id,
    name,
    description,
    category,
    panelId,
    parameters,
  };
}

/**
 * Create a tool parameter
 */
export function createParameter(
  name: string,
  type: ToolParameterType,
  description: string,
  required = false,
  options?: { default?: unknown; options?: Array<{ label: string; value: string | number }> }
): ToolParameter {
  return {
    name,
    type,
    description,
    required,
    default: options?.default,
    options: options?.options,
  };
}
