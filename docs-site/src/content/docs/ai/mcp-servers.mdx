---
title: MCP Servers
description: Model Context Protocol servers for AI-driven infrastructure control
---

import { Aside, Card, CardGrid } from '@astrojs/starlight/components';

MCP (Model Context Protocol) servers provide a standardized interface for AI agents to interact with QemuWeb. This page documents the available servers and their capabilities.

## What is MCP?

The Model Context Protocol is a standard for AI tool integration. It defines:

- **Tools**: Functions the AI can call
- **Resources**: Data the AI can access
- **Prompts**: Pre-defined interaction templates

MCP servers communicate via JSON-RPC over stdio or HTTP.

## Available Servers

<CardGrid>
  <Card title="vm-control" icon="rocket">
    Manages VM lifecycle: start, stop, execute commands.
  </Card>
  <Card title="sdn-control-plane" icon="seti:pipeline">
    Controls virtual network topology and routing.
  </Card>
  <Card title="firewall" icon="warning">
    Manages firewall rules and security policies.
  </Card>
  <Card title="observability" icon="telescope">
    Provides metrics, logs, and tracing data.
  </Card>
</CardGrid>

## vm-control Server

Manages virtual machine lifecycle and operations.

### Tools

#### `start_vm`

Start a new virtual machine.

```typescript
{
  name: "start_vm",
  description: "Start a new virtual machine with the specified profile",
  inputSchema: {
    type: "object",
    properties: {
      profile: {
        type: "string",
        enum: ["alpineLinux", "alpineRouter", "devContainer", "vault"],
        description: "The VM profile to use"
      },
      name: {
        type: "string",
        description: "Optional name for the VM"
      },
      memory: {
        type: "number",
        description: "RAM in MB (overrides profile default)"
      }
    },
    required: ["profile"]
  }
}
```

**Example:**
```json
{
  "tool": "start_vm",
  "arguments": {
    "profile": "alpineLinux",
    "name": "web-server",
    "memory": 256
  }
}
```

#### `stop_vm`

Stop a running virtual machine.

```typescript
{
  name: "stop_vm",
  description: "Stop a running virtual machine",
  inputSchema: {
    type: "object",
    properties: {
      vmId: {
        type: "string",
        description: "ID of the VM to stop"
      },
      force: {
        type: "boolean",
        description: "Force stop without graceful shutdown"
      }
    },
    required: ["vmId"]
  }
}
```

#### `execute_command`

Execute a command inside a VM.

```typescript
{
  name: "execute_command",
  description: "Execute a shell command in a running VM",
  inputSchema: {
    type: "object",
    properties: {
      vmId: {
        type: "string",
        description: "ID of the target VM"
      },
      command: {
        type: "string",
        description: "Command to execute"
      },
      timeout: {
        type: "number",
        description: "Timeout in seconds (default: 30)"
      }
    },
    required: ["vmId", "command"]
  }
}
```

#### `list_vms`

List all virtual machines.

```typescript
{
  name: "list_vms",
  description: "List all VMs and their current status",
  inputSchema: {
    type: "object",
    properties: {}
  }
}
```

**Response:**
```json
{
  "vms": [
    {
      "id": "vm-abc123",
      "name": "web-server",
      "profile": "alpineLinux",
      "status": "running",
      "memory": 128,
      "uptime": 3600
    }
  ]
}
```

## sdn-control-plane Server

Manages virtual network topology.

### Tools

#### `create_network`

Create a new virtual network.

```typescript
{
  name: "create_network",
  description: "Create a new virtual network",
  inputSchema: {
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "Network name"
      },
      type: {
        type: "string",
        enum: ["nat", "internal", "routed"],
        description: "Network type"
      },
      cidr: {
        type: "string",
        description: "Network CIDR (e.g., '10.0.0.0/24')"
      },
      gateway: {
        type: "string",
        description: "Gateway IP address"
      },
      dhcp: {
        type: "boolean",
        description: "Enable DHCP server"
      }
    },
    required: ["name", "type", "cidr"]
  }
}
```

#### `add_vm_to_network`

Connect a VM to a network.

```typescript
{
  name: "add_vm_to_network",
  description: "Connect a VM to a virtual network",
  inputSchema: {
    type: "object",
    properties: {
      vmId: {
        type: "string",
        description: "ID of the VM"
      },
      networkName: {
        type: "string",
        description: "Name of the network"
      },
      ip: {
        type: "string",
        description: "Static IP address (optional, uses DHCP if omitted)"
      }
    },
    required: ["vmId", "networkName"]
  }
}
```

#### `create_route`

Add a routing rule.

```typescript
{
  name: "create_route",
  description: "Create a routing rule between networks",
  inputSchema: {
    type: "object",
    properties: {
      source: {
        type: "string",
        description: "Source network name"
      },
      destination: {
        type: "string",
        description: "Destination network name or CIDR"
      },
      gateway: {
        type: "string",
        description: "Gateway IP address"
      }
    },
    required: ["source", "destination", "gateway"]
  }
}
```

#### `get_topology`

Get current network topology.

```typescript
{
  name: "get_topology",
  description: "Get the current network topology as a graph",
  inputSchema: {
    type: "object",
    properties: {}
  }
}
```

**Response:**
```json
{
  "networks": [
    { "name": "management", "cidr": "10.0.0.0/24", "type": "nat" }
  ],
  "vms": [
    { "id": "vm-1", "name": "web", "networks": ["management"] }
  ],
  "routes": [
    { "from": "internal", "to": "0.0.0.0/0", "via": "10.0.0.1" }
  ]
}
```

## firewall Server

Manages firewall rules and security policies.

### Tools

#### `add_rule`

Add a firewall rule.

```typescript
{
  name: "add_rule",
  description: "Add a firewall rule",
  inputSchema: {
    type: "object",
    properties: {
      action: {
        type: "string",
        enum: ["allow", "deny", "log"],
        description: "Rule action"
      },
      source: {
        type: "object",
        properties: {
          network: { type: "string" },
          ip: { type: "string" },
          port: { type: "string" }
        }
      },
      destination: {
        type: "object",
        properties: {
          network: { type: "string" },
          ip: { type: "string" },
          port: { type: "string" }
        }
      },
      protocol: {
        type: "string",
        enum: ["tcp", "udp", "icmp", "any"]
      },
      priority: {
        type: "number",
        description: "Lower = higher priority"
      }
    },
    required: ["action"]
  }
}
```

**Example:**
```json
{
  "tool": "add_rule",
  "arguments": {
    "action": "allow",
    "source": { "network": "dmz" },
    "destination": { "network": "backend", "port": "5432" },
    "protocol": "tcp",
    "priority": 100
  }
}
```

#### `remove_rule`

Remove a firewall rule.

```typescript
{
  name: "remove_rule",
  description: "Remove a firewall rule by ID",
  inputSchema: {
    type: "object",
    properties: {
      ruleId: {
        type: "string",
        description: "ID of the rule to remove"
      }
    },
    required: ["ruleId"]
  }
}
```

#### `list_rules`

List all firewall rules.

```typescript
{
  name: "list_rules",
  description: "List all firewall rules",
  inputSchema: {
    type: "object",
    properties: {
      filter: {
        type: "object",
        properties: {
          network: { type: "string" },
          action: { type: "string" }
        }
      }
    }
  }
}
```

## observability Server

Provides metrics, logs, and tracing.

### Tools

#### `get_logs`

Retrieve logs from VMs or the system.

```typescript
{
  name: "get_logs",
  description: "Get logs from a VM or the system",
  inputSchema: {
    type: "object",
    properties: {
      vmId: {
        type: "string",
        description: "VM ID (omit for system logs)"
      },
      lines: {
        type: "number",
        description: "Number of lines to retrieve"
      },
      filter: {
        type: "string",
        description: "Grep-style filter pattern"
      }
    }
  }
}
```

#### `get_metrics`

Get performance metrics.

```typescript
{
  name: "get_metrics",
  description: "Get performance metrics",
  inputSchema: {
    type: "object",
    properties: {
      vmId: {
        type: "string",
        description: "VM ID for VM-specific metrics"
      },
      metrics: {
        type: "array",
        items: { type: "string" },
        description: "Metric names to retrieve"
      }
    }
  }
}
```

**Response:**
```json
{
  "cpu_usage": 45.2,
  "memory_used_mb": 64,
  "memory_total_mb": 128,
  "disk_reads": 1024,
  "disk_writes": 256,
  "network_rx_bytes": 50000,
  "network_tx_bytes": 12000
}
```

## Using MCP Servers

### With LangGraph

```typescript
import { createAgent } from '@qemuweb/agent';
import { vmControlServer, sdnControlServer, firewallServer } from '@qemuweb/mcp-servers';

const agent = createAgent({
  llm,
  mcpServers: [
    vmControlServer,
    sdnControlServer,
    firewallServer,
  ],
});

const result = await agent.invoke({
  input: "Create a secure web environment",
});
```

### Direct MCP Client

```typescript
import { Client } from '@modelcontextprotocol/sdk/client';

const client = new Client({
  transport: 'stdio',
});

await client.connect();

// List available tools
const tools = await client.listTools();

// Call a tool
const result = await client.callTool('start_vm', {
  profile: 'alpineLinux',
});
```

## Implementing Custom MCP Servers

```typescript
import { Server } from '@modelcontextprotocol/sdk/server';

const server = new Server({
  name: 'custom-server',
  version: '1.0.0',
});

server.addTool({
  name: 'my_custom_tool',
  description: 'Does something custom',
  inputSchema: {
    type: 'object',
    properties: {
      param: { type: 'string' },
    },
  },
  handler: async ({ param }) => {
    // Implementation
    return { result: `Processed: ${param}` };
  },
});

server.start();
```

## Security

<Aside type="caution">
  MCP servers can perform powerful operations. Always validate inputs and implement proper authorization.
</Aside>

Best practices:

1. **Input validation**: Validate all tool inputs
2. **Rate limiting**: Prevent abuse
3. **Audit logging**: Log all operations
4. **Least privilege**: Only expose necessary tools
