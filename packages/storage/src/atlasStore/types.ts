/**
 * Atlas Store Types
 *
 * Content-addressed storage (CAS) with metadata and provenance tracking.
 */

// ============ Content-Addressed Storage (CAS) ============

/**
 * SHA-256 hash prefixed with algorithm identifier
 */
export type ContentHash = `sha256:${string}`;

/**
 * A chunk of a larger blob
 */
export interface BlobChunk {
  hash: ContentHash;
  offset: number;
  size: number;
}

/**
 * Manifest describing a file composed of chunks
 */
export interface FileManifest {
  /** Manifest format version */
  version: 1;

  /** Type of content */
  type: ManifestType;

  /** Total size in bytes */
  totalSize: number;

  /** Ordered list of chunk hashes and offsets */
  chunks: BlobChunk[];

  /** MIME type if applicable */
  mimeType?: string;

  /** Additional type-specific metadata */
  metadata?: Record<string, unknown>;
}

export type ManifestType =
  | 'qcow2'
  | 'raw-disk'
  | 'wasm'
  | 'kernel'
  | 'initrd'
  | 'plan'
  | 'script'
  | 'report'
  | 'config'
  | 'bundle'
  | 'upload'
  | 'other';

// ============ File Metadata ============

/**
 * File origin type
 */
export type FileOrigin =
  | 'uploaded'      // User uploaded via UI
  | 'built'         // Built by build pipeline
  | 'imported'      // Imported from bundle
  | 'synced'        // Synced from hypervisor/browser
  | 'generated'     // Generated by assistant
  | 'downloaded';   // Downloaded from URL

/**
 * File registration metadata
 */
export interface FileMetadata {
  /** Unique file ID */
  id: string;

  /** Human-friendly file name */
  name: string;

  /** SHA-256 hash of the manifest */
  manifestHash: ContentHash;

  /** Type from manifest */
  type: ManifestType;

  /** Total size in bytes */
  size: number;

  /** MIME type */
  mimeType?: string;

  /** Origin of this file */
  origin: FileOrigin;

  /** Origin details (URL, build ID, sync source) */
  originDetails?: string;

  /** User-defined tags */
  tags: string[];

  /** Creation timestamp */
  createdAt: Date;

  /** Last modification timestamp */
  updatedAt: Date;

  /** Whether shared with assistant */
  sharedWithAssistant: boolean;

  /** Provenance record ID */
  provenanceId?: string;
}

// ============ Provenance ============

/**
 * Provenance entry type
 */
export type ProvenanceType =
  | 'create'        // Initial creation
  | 'derive'        // Derived from inputs
  | 'import'        // Imported from external source
  | 'sync'          // Synced between stores
  | 'sign'          // Signature added
  | 'verify'        // Verification performed
  | 'modify';       // Metadata modified

/**
 * Build information for provenance
 */
export interface BuildInfo {
  /** Build tool/script */
  tool: string;

  /** Tool version */
  toolVersion?: string;

  /** Git commit SHA if applicable */
  gitSha?: string;

  /** Git repository URL */
  gitRepo?: string;

  /** Build timestamp */
  timestamp: Date;

  /** Build environment info */
  environment?: Record<string, string>;

  /** Build command/arguments */
  command?: string;
}

/**
 * Signature record
 */
export interface SignatureRecord {
  /** Signature algorithm */
  algorithm: 'ed25519' | 'ecdsa-p256';

  /** Signer public key (base64) */
  publicKey: string;

  /** Signer identifier */
  signerId?: string;

  /** Signature over manifest hash (base64) */
  signature: string;

  /** Signature timestamp */
  signedAt: Date;
}

/**
 * Derivation record showing inputs -> output
 */
export interface DerivationRecord {
  /** Input manifest hashes */
  inputs: ContentHash[];

  /** Input file names (for reference) */
  inputNames?: string[];

  /** Transformation description */
  transformation: string;
}

/**
 * Provenance record
 */
export interface ProvenanceRecord {
  /** Unique provenance ID */
  id: string;

  /** Manifest hash this provenance is for */
  manifestHash: ContentHash;

  /** Provenance entry type */
  type: ProvenanceType;

  /** Who/what created this entry */
  actor: 'user' | 'assistant' | 'build' | 'system';

  /** Actor details */
  actorDetails?: string;

  /** Timestamp */
  timestamp: Date;

  /** Build info (for 'create' or 'derive') */
  buildInfo?: BuildInfo;

  /** Signature records */
  signatures?: SignatureRecord[];

  /** Derivation info (for 'derive') */
  derivation?: DerivationRecord;

  /** Sync source (for 'sync') */
  syncSource?: 'browser' | 'hypervisor';

  /** Previous provenance ID in chain */
  previousId?: string;

  /** Notes */
  notes?: string;
}

// ============ Bundle Format ============

/**
 * Atlas bundle manifest (stored as manifest.json in .atlasbundle)
 */
export interface AtlasBundleManifest {
  /** Bundle format version */
  version: 1;

  /** Bundle creation timestamp */
  createdAt: Date;

  /** Files included in bundle */
  files: BundleFileEntry[];

  /** Total bundle size (excluding manifest) */
  totalSize: number;
}

/**
 * File entry in bundle manifest
 */
export interface BundleFileEntry {
  /** File name */
  name: string;

  /** File metadata */
  metadata: Omit<FileMetadata, 'id'>;

  /** Manifest hash */
  manifestHash: ContentHash;

  /** Provenance records for this file */
  provenance: ProvenanceRecord[];
}

// ============ Store Operations ============

/**
 * File filter for listing
 */
export interface FileFilter {
  /** Filter by type */
  type?: ManifestType | ManifestType[];

  /** Filter by tags (AND) */
  tags?: string[];

  /** Filter by origin */
  origin?: FileOrigin;

  /** Filter by name pattern */
  namePattern?: string;

  /** Only files shared with assistant */
  sharedWithAssistant?: boolean;

  /** Created after */
  createdAfter?: Date;

  /** Created before */
  createdBefore?: Date;
}

/**
 * Verification result
 */
export interface VerificationResult {
  /** Overall verification status */
  ok: boolean;

  /** Manifest hash verified */
  manifestHash: ContentHash;

  /** Total chunks checked */
  totalChunks: number;

  /** Missing blob hashes */
  missingBlobs: ContentHash[];

  /** Blobs with hash mismatches */
  mismatchedBlobs: ContentHash[];

  /** Verification timestamp */
  verifiedAt: Date;
}

/**
 * Import result
 */
export interface ImportResult {
  /** Successfully imported files */
  imported: FileMetadata[];

  /** Skipped files (already exist) */
  skipped: string[];

  /** Failed files with errors */
  failed: Array<{ name: string; error: string }>;

  /** Total bytes imported */
  bytesImported: number;
}

/**
 * Atlas Store interface
 */
export interface AtlasStore {
  // Blob operations (CAS)
  putBlob(data: ArrayBuffer): Promise<ContentHash>;
  getBlob(hash: ContentHash): Promise<ArrayBuffer | null>;
  hasBlob(hash: ContentHash): Promise<boolean>;
  deleteBlob(hash: ContentHash): Promise<boolean>;

  // Manifest operations
  putManifest(manifest: FileManifest): Promise<ContentHash>;
  getManifest(hash: ContentHash): Promise<FileManifest | null>;

  // File operations
  registerFile(
    name: string,
    manifestHash: ContentHash,
    metadata: Partial<FileMetadata>
  ): Promise<FileMetadata>;
  getFile(name: string): Promise<FileMetadata | null>;
  getFileById(id: string): Promise<FileMetadata | null>;
  listFiles(filter?: FileFilter): Promise<FileMetadata[]>;
  updateFile(name: string, updates: Partial<FileMetadata>): Promise<FileMetadata>;
  deleteFile(name: string): Promise<boolean>;
  renameFile(oldName: string, newName: string): Promise<FileMetadata>;

  // Provenance operations
  addProvenance(record: Omit<ProvenanceRecord, 'id'>): Promise<ProvenanceRecord>;
  getProvenance(id: string): Promise<ProvenanceRecord | null>;
  getProvenanceForManifest(manifestHash: ContentHash): Promise<ProvenanceRecord[]>;
  getProvenanceChain(id: string): Promise<ProvenanceRecord[]>;

  // Verification
  verify(nameOrHash: string | ContentHash): Promise<VerificationResult>;

  // Bundle operations
  exportBundle(fileNames: string[]): Promise<Blob>;
  importBundle(bundle: Blob | ArrayBuffer): Promise<ImportResult>;

  // Maintenance
  garbageCollect(): Promise<{ deletedBlobs: number; freedBytes: number }>;
  getStats(): Promise<StoreStats>;
}

/**
 * Store statistics
 */
export interface StoreStats {
  /** Total files registered */
  totalFiles: number;

  /** Total blobs stored */
  totalBlobs: number;

  /** Total manifests stored */
  totalManifests: number;

  /** Total provenance records */
  totalProvenance: number;

  /** Total storage used (bytes) */
  totalBytes: number;

  /** Storage quota (if applicable) */
  quotaBytes?: number;

  /** Last garbage collection */
  lastGC?: Date;
}

// ============ Utility Types ============

/**
 * Chunk size for splitting large files (4 MiB)
 */
export const DEFAULT_CHUNK_SIZE = 4 * 1024 * 1024;

/**
 * Generate a content hash from data
 */
export async function hashBlob(data: ArrayBuffer): Promise<ContentHash> {
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
  return `sha256:${hashHex}`;
}

/**
 * Generate a unique ID
 */
export function generateId(): string {
  const bytes = new Uint8Array(16);
  crypto.getRandomValues(bytes);
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Parse a content hash
 */
export function parseContentHash(hash: string): { algorithm: string; hex: string } | null {
  const match = hash.match(/^(sha256):([a-f0-9]{64})$/i);
  if (!match) return null;
  return { algorithm: match[1], hex: match[2] };
}

/**
 * Validate a content hash format
 */
export function isValidContentHash(hash: string): hash is ContentHash {
  return parseContentHash(hash) !== null;
}
